太棒了！您这次的修改非常成功，已经无限接近最终目标了。我详细审查了您的所有文件，可以确认：

1.  **架构是完美的**：您使用 `QGridLayout` 来叠加 `VideoDisplayWidget` 和 `PaintingOverlay` 的方式是完全正确的。
2.  **协调是正确的**：`MutiCamApp` 现在能够正确地在 `resizeEvent` 和 `onCameraFrameReady` 中调用 `syncOverlayTransforms` 来同步两个图层的坐标系。
3.  **职责分离是清晰的**：`VideoDisplayWidget` 已经成功瘦身，只负责显示视频。

您现在遇到的“样式和逻辑不一致”的问题，原因非常明确：**您将旧 `VideoDisplayWidget` 的“功能声明”迁移到了 `PaintingOverlay`，但没有将与之对应的、复杂的“功能实现”完全迁移过来。**

简单来说，您的 `PaintingOverlay.cpp` 文件中的代码，仍然是您在重构早期编写的简化版本，而不是您在 `VideoDisplayWidget` 中打磨完善的最终版本。

我们现在要做的就是完成这最后一步：用您旧的、功能完备的实现来“填充”新的 `PaintingOverlay.cpp`。

---

### 最终修复方案：完成代码内容的迁移

这个方案将确保您的绘图样式、交互逻辑、右键菜单、选择高亮等所有功能都恢复到您之前的最佳状态。

#### 第 1 步：统一 `PaintingOverlay.h` 中的数据结构

请将 `PaintingOverlay.h` 中的绘图对象结构体**完全替换**为以下定义。这些定义来自于您之前功能最全的 `VideoDisplayWidget.h`，确保了数据结构的一致性。

```cpp
// PaintingOverlay.h

// ... (include 和 class 声明)

public:
    // ...

    // 【关键修复】: 使用功能完备的绘图对象结构体
    struct PointObject {
        QPointF position;
    };

    struct LineObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::green;
        int thickness = 2;
        bool isDashed = false;
    };

    struct LineSegmentObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::green;
        double thickness = 2.0;
        bool isDashed = false;
    };

    struct CircleObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::blue;
        int thickness = 2;
        QPointF center;
        double radius = 0.0;
    };

    struct FineCircleObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::magenta;
        int thickness = 2;
        QPointF center;
        double radius = 0.0;
    };

    struct ParallelObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::cyan;
        int thickness = 2;
        double distance = 0.0;
        double angle = 0.0;
        bool isPreview = false;
    };

    struct TwoLinesObject {
        QVector<QPointF> points;
        bool isCompleted = false;
        QColor color = Qt::yellow;
        int thickness = 2;
        double angle = 0.0;
        QPointF intersection;
    };

    // ... (其他声明保持不变)
```
**注意：** 我已经为您整合并清理了这些结构体，请直接复制粘贴替换。

#### 第 2 步：用旧的实现**完全替换** `PaintingOverlay.cpp` 的内容

这是最关键的一步。您需要打开您之前**功能正常的 `VideoDisplayWidget.cpp` 文件**（作为源文件），然后用它的内容来替换 `PaintingOverlay.cpp` 中的大部分函数。

**操作指南：**

1.  **打开旧的 `VideoDisplayWidget.cpp` 和新的 `PaintingOverlay.cpp`。**

2.  **保留 `PaintingOverlay.cpp` 的头部和构造函数：**
    ```cpp
    #include "PaintingOverlay.h"
    // ... (所有需要的 include)

    PaintingOverlay::PaintingOverlay(QWidget *parent) 
        : QWidget(parent)
        , // ... (所有成员变量的初始化列表)
    {
        setAttribute(Qt::WA_TranslucentBackground);
        setAttribute(Qt::WA_NoSystemBackground);
        setMouseTracking(true);
    }
    ```

3.  **保留 `PaintingOverlay.cpp` 中新增的协调函数：**
    ```cpp
    void PaintingOverlay::setTransforms(const QPointF& offset, double scale, const QSize& imageSize) { /* ... */ }
    void PaintingOverlay::setViewName(const QString& viewName) { /* ... */ }
    QString PaintingOverlay::getViewName() const { /* ... */ }
    PaintingOverlay::DrawingState PaintingOverlay::getDrawingState() const { /* ... */ }
    void PaintingOverlay::setDrawingState(const DrawingState& state) { /* ... */ }
    ```

4.  **【核心】** 将旧 `VideoDisplayWidget.cpp` 中的**以下所有函数**的**完整实现**，复制并粘贴到 `PaintingOverlay.cpp` 中，**覆盖**掉现有的简化版实现：
    *   `paintEvent`
    *   `mousePressEvent`
    *   `mouseMoveEvent`
    *   `mouseReleaseEvent` (如果有的话)
    *   `contextMenuEvent`
    *   `resizeEvent` (如果有的话)
    *   `clearAllDrawings`
    *   `undoLastDrawing`
    *   `commitDrawingAction`
    *   `startDrawing` 和 `stopDrawing`
    *   **所有** `draw...` 和 `drawSingle...` 函数
    *   **所有** `handle...Click` 函数
    *   **所有** `calculate...` 函数
    *   **所有** `hitTest...` 函数
    *   **所有**选择相关函数 (`enableSelection`, `clearSelection`, `handleSelectionClick` 等)
    *   **所有**绘图辅助函数 (`createPen`, `createFont`, `drawText...` 等)

5.  **进行最终适配：**
    *   **全局查找替换**: 在 `PaintingOverlay.cpp` 中，将所有 `getScaleFactor()` 替换为 `m_scaleFactor`。
    *   **修改坐标转换**: 在 `mousePressEvent` 和 `mouseMoveEvent` 的开头，确保坐标转换的调用是正确的：
        ```cpp
        QPointF imagePos = widgetToImage(event->pos());
        ```
        并且后续都使用 `imagePos`。
    *   **修改 `paintEvent`**:
        ```cpp
        void PaintingOverlay::paintEvent(QPaintEvent *event)
        {
            QPainter painter(this);
            // ... (设置 render hints)

            // 【不再绘制视频帧，只设置变换】
            QTransform transform;
            transform.translate(m_imageOffset.x(), m_imageOffset.y());
            transform.scale(m_scaleFactor, m_scaleFactor);
            painter.setTransform(transform);
            
            // ... (从旧 paintEvent 粘贴过来的所有 draw... 调用)
        }
        ```
    *   **修改 `calculateExtendedLine`**: 确保它使用的是 `m_imageSize` 而不是 `m_videoFrame.size()`。

#### 第 3 步：清理 `PaintingOverlay.h`

完成 `.cpp` 的替换后，回到 `.h` 文件，确保所有函数的声明都与您粘贴过来的实现相匹配。删除所有冗余或冲突的函数声明（例如，如果您有多个 `drawText...` 的重载，请只保留您实际使用的那几个）。

---

### 总结

这个过程本质上是将您在 `VideoDisplayWidget` 中已经完成的所有工作，整体搬迁到一个新的“房子” (`PaintingOverlay`) 里。因为您已经搭建好了房子（`.h` 文件），现在需要做的就是把所有的“家具和家电”（`.cpp` 中的实现）搬进去，并接上水电（修改坐标转换和 `paintEvent`）。

完成这次彻底的内容迁移后，您的代码将达到最终的理想状态：
*   **架构清晰**：`VideoDisplayWidget` 显示视频，`PaintingOverlay` 负责交互和绘图。
*   **功能完整**：所有绘图样式、预览、选择、右键菜单等高级功能全部恢复。
*   **性能优异**：从根本上解决了UI卡顿的问题。

请耐心完成这次代码的“搬家”工作，这之后您的重构就圆满成功了。